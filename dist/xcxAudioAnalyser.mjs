var img$2 = "data:image/png;base64,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";

var img$1 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3c!-- Created with Inkscape (http://www.inkscape.org/) --%3e%3csvg width='45.539089mm' height='45.539089mm' viewBox='0 0 45.539089 45.539089' version='1.1' id='svg1' xmlns='http://www.w3.org/2000/svg' xmlns:svg='http://www.w3.org/2000/svg'%3e %3cstyle id='style2'%3e.measure-arrow%7b%7d.measure-label%7b%7d.measure-line%7b%7d%3c/style%3e %3cdefs id='defs1' /%3e %3cg id='layer1' transform='translate(-127.96265%2c-119.29199)'%3e %3cg id='g67'%3e %3cg id='g41' transform='translate(-1.8904963%2c80.878361)'%3e %3ccircle style='fill:white%3bstroke:lime%3bstroke-width:0%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none' id='circle42' cx='152.62268' cy='61.183167' r='22.769543' /%3e %3ccircle style='fill:green%3bstroke:lime%3bstroke-width:2.64583%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none' id='circle40' cx='152.62268' cy='61.183159' r='18.854073' /%3e %3cpath style='fill:none%3bstroke:lime%3bstroke-width:2.30525%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none' d='m 134.00831%2c61.429285 c 0%2c0 0.949%2c5.201792 2.18404%2c5.201792 1.23504%2c0 1.14916%2c-10.396513 2.43891%2c-10.39593 1.28975%2c5.83e-4 2.15317%2c14.71827 3.43892%2c14.71827 1.28575%2c0 1.50233%2c-19.074701 3.43891%2c-19.04061 1.93658%2c0.03409 1.18572%2c23.80373 3.43892%2c23.80373 2.2532%2c0 1.21144%2c-29.06685 3.43891%2c-29.066851 2.22747%2c-1e-6 1.72889%2c29.066851 3.43892%2c29.066851 1.71003%2c0 1.82227%2c-23.80373 3.43891%2c-23.80373 1.61664%2c0 2.04509%2c19.04061 3.43892%2c19.04061 1.39383%2c0 1.67534%2c-14.71827 3.43891%2c-14.71827 1.76357%2c0 0.81234%2c10.39593 2.43891%2c10.39593 1.62657%2c0 2.65556%2c-5.201792 2.65556%2c-5.201792' id='path41' /%3e %3c/g%3e %3cg id='g66' transform='translate(2.5268457%2c-130.35602)'%3e %3cpath style='fill:none%3bstroke:white%3bstroke-width:2.64583%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none' d='m 177.9319%2c279.09567 c 1.83103%2c-1.69182 2.97863%2c-4.11263 2.97863%2c-6.80217 -6.5e-4%2c-2.58345 -1.08046%2c-5.04918 -2.97863%2c-6.80165' id='path60' /%3e %3cpath style='fill:none%3bstroke:white%3bstroke-width:2.64582%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none' d='m 181.13274%2c282.65462 c 2.80438%2c-2.56801 4.56352%2c-6.25891 4.56355%2c-10.36112 -4.4e-4%2c-3.94106 -1.65653%2c-7.70064 -4.56406%2c-10.36113' id='path64' /%3e %3cpath style='fill:none%3bstroke:white%3bstroke-width:2.64583%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none' d='m 184.33306%2c286.21361 c 3.77794%2c-3.44413 6.14892%2c-8.40506 6.14898%2c-13.92008 -3.1e-4%2c-5.29851 -2.2327%2c-10.35177 -6.14949%2c-13.92008' id='path65' /%3e %3c/g%3e %3cg id='g65' transform='translate(-44.513087%2c-130.36219)'%3e %3cpath style='fill:none%3bstroke:white%3bstroke-width:2.64583%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none' d='m 165.51871%2c265.36162 c -1.98749%2c1.75597 -3.12673%2c4.2798 -3.12901%2c6.93188 0%2c2.76102 1.20973%2c5.23836 3.12642%2c6.93497' id='path63' /%3e %3cpath style='fill:none%3bstroke:white%3bstroke-width:2.64582%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none' d='m 162.30547%2c261.82385 c -2.98647%2c2.66122 -4.69663%2c6.46952 -4.70152%2c10.46965 3e-5%2c4.16515 1.81447%2c7.90515 4.69428%2c10.47739' id='path61' /%3e %3cpath style='fill:none%3bstroke:white%3bstroke-width:2.64583%3bstroke-linecap:round%3bstroke-linejoin:round%3bstroke-dasharray:none' d='m 159.09223%2c258.28608 c -3.98548%2c3.56642 -6.26659%2c8.65921 -6.27404%2c14.00742 6e-5%2c5.56926 2.4192%2c10.57205 6.26215%2c14.01981' id='path62' /%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

var en$1 = {
	"xcxAudioAnalyser.entry.name": "Audio Analyser",
	"xcxAudioAnalyser.entry.description": "Analyze sound spectra and waveforms"
};
var ja$1 = {
	"xcxAudioAnalyser.entry.name": "Audio Analyser",
	"xcxAudioAnalyser.entry.description": "音のスペクトル解析や波形を調べる"
};
var translations$1 = {
	en: en$1,
	ja: ja$1,
	"ja-Hira": {
	"xcxAudioAnalyser.entry.name": "オーディオ アナライザー",
	"xcxAudioAnalyser.entry.description": "おと の スペクトルかいせき や はけい を しらべる"
}
};

/**
 * This is an extension for Xcratch.
 */


/**
 * Formatter to translate the messages in this extension.
 * This will be replaced which is used in the React component.
 * @param {object} messageData - data for format-message
 * @returns {string} - translated message for the current locale
 */
var formatMessage$1 = function formatMessage(messageData) {
  return messageData.defaultMessage;
};
var entry = {
  get name() {
    return formatMessage$1({
      id: 'xcxAudioAnalyser.entry.name',
      defaultMessage: 'Audio Analyser',
      description: 'name of the extension'
    });
  },
  extensionId: 'xcxAudioAnalyser',
  extensionURL: 'https://yokobond.github.io/xcx-audio-analyser/dist/xcxAudioAnalyser.mjs',
  collaborator: 'yokobond',
  iconURL: img$2,
  insetIconURL: img$1,
  get description() {
    return formatMessage$1({
      defaultMessage: 'an extension for Xcratch',
      description: 'Description for this extension',
      id: 'xcxAudioAnalyser.entry.description'
    });
  },
  featured: true,
  disabled: false,
  bluetoothRequired: false,
  internetConnectionRequired: false,
  helpLink: 'https://yokobond.github.io/xcx-audio-analyser/',
  setFormatMessage: function setFormatMessage(formatter) {
    formatMessage$1 = formatter;
  },
  translationMap: translations$1
};

function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}

function _classCallCheck$1(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

function _typeof$2(o) {
  "@babel/helpers - typeof";

  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof$2(o);
}

function toPrimitive$1(t, r) {
  if ("object" != _typeof$2(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$2(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (String )(t);
}

function toPropertyKey$1(t) {
  var i = toPrimitive$1(t, "string");
  return "symbol" == _typeof$2(i) ? i : i + "";
}

function _defineProperties$1(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey$1(o.key), o);
  }
}
function _createClass$1(e, r, t) {
  return r && _defineProperties$1(e.prototype, r), t && _defineProperties$1(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var regeneratorRuntime$1 = {exports: {}};

var _typeof$1 = {exports: {}};

(function (module) {
  function _typeof(o) {
    "@babel/helpers - typeof";

    return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
  }
  module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(_typeof$1);
var _typeofExports = _typeof$1.exports;

(function (module) {
  var _typeof = _typeofExports["default"];
  function _regeneratorRuntime() {

    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
      return e;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    var t,
      e = {},
      r = Object.prototype,
      n = r.hasOwnProperty,
      o = Object.defineProperty || function (t, e, r) {
        t[e] = r.value;
      },
      i = "function" == typeof Symbol ? Symbol : {},
      a = i.iterator || "@@iterator",
      c = i.asyncIterator || "@@asyncIterator",
      u = i.toStringTag || "@@toStringTag";
    function define(t, e, r) {
      return Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), t[e];
    }
    try {
      define({}, "");
    } catch (t) {
      define = function define(t, e, r) {
        return t[e] = r;
      };
    }
    function wrap(t, e, r, n) {
      var i = e && e.prototype instanceof Generator ? e : Generator,
        a = Object.create(i.prototype),
        c = new Context(n || []);
      return o(a, "_invoke", {
        value: makeInvokeMethod(t, r, c)
      }), a;
    }
    function tryCatch(t, e, r) {
      try {
        return {
          type: "normal",
          arg: t.call(e, r)
        };
      } catch (t) {
        return {
          type: "throw",
          arg: t
        };
      }
    }
    e.wrap = wrap;
    var h = "suspendedStart",
      l = "suspendedYield",
      f = "executing",
      s = "completed",
      y = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var p = {};
    define(p, a, function () {
      return this;
    });
    var d = Object.getPrototypeOf,
      v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t) {
      ["next", "throw", "return"].forEach(function (e) {
        define(t, e, function (t) {
          return this._invoke(e, t);
        });
      });
    }
    function AsyncIterator(t, e) {
      function invoke(r, o, i, a) {
        var c = tryCatch(t[r], t, o);
        if ("throw" !== c.type) {
          var u = c.arg,
            h = u.value;
          return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
            invoke("next", t, i, a);
          }, function (t) {
            invoke("throw", t, i, a);
          }) : e.resolve(h).then(function (t) {
            u.value = t, i(u);
          }, function (t) {
            return invoke("throw", t, i, a);
          });
        }
        a(c.arg);
      }
      var r;
      o(this, "_invoke", {
        value: function value(t, n) {
          function callInvokeWithMethodAndArg() {
            return new e(function (e, r) {
              invoke(t, n, e, r);
            });
          }
          return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e, r, n) {
      var o = h;
      return function (i, a) {
        if (o === f) throw Error("Generator is already running");
        if (o === s) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var c = n.delegate;
          if (c) {
            var u = maybeInvokeDelegate(c, n);
            if (u) {
              if (u === y) continue;
              return u;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (o === h) throw o = s, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = f;
          var p = tryCatch(e, r, n);
          if ("normal" === p.type) {
            if (o = n.done ? s : l, p.arg === y) continue;
            return {
              value: p.arg,
              done: n.done
            };
          }
          "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
        }
      };
    }
    function maybeInvokeDelegate(e, r) {
      var n = r.method,
        o = e.iterator[n];
      if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
      var i = tryCatch(o, e.iterator, r.arg);
      if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
      var a = i.arg;
      return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
    }
    function pushTryEntry(t) {
      var e = {
        tryLoc: t[0]
      };
      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
    }
    function resetTryEntry(t) {
      var e = t.completion || {};
      e.type = "normal", delete e.arg, t.completion = e;
    }
    function Context(t) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(e) {
      if (e || "" === e) {
        var r = e[a];
        if (r) return r.call(e);
        if ("function" == typeof e.next) return e;
        if (!isNaN(e.length)) {
          var o = -1,
            i = function next() {
              for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
              return next.value = t, next.done = !0, next;
            };
          return i.next = i;
        }
      }
      throw new TypeError(_typeof(e) + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
      var e = "function" == typeof t && t.constructor;
      return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
    }, e.mark = function (t) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
    }, e.awrap = function (t) {
      return {
        __await: t
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
      return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
      void 0 === i && (i = Promise);
      var a = new AsyncIterator(wrap(t, r, n, o), i);
      return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
        return t.done ? t.value : a.next();
      });
    }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
      return this;
    }), define(g, "toString", function () {
      return "[object Generator]";
    }), e.keys = function (t) {
      var e = Object(t),
        r = [];
      for (var n in e) r.push(n);
      return r.reverse(), function next() {
        for (; r.length;) {
          var t = r.pop();
          if (t in e) return next.value = t, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, e.values = values, Context.prototype = {
      constructor: Context,
      reset: function reset(e) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
      },
      stop: function stop() {
        this.done = !0;
        var t = this.tryEntries[0].completion;
        if ("throw" === t.type) throw t.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(e) {
        if (this.done) throw e;
        var r = this;
        function handle(n, o) {
          return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
        }
        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
          var i = this.tryEntries[o],
            a = i.completion;
          if ("root" === i.tryLoc) return handle("end");
          if (i.tryLoc <= this.prev) {
            var c = n.call(i, "catchLoc"),
              u = n.call(i, "finallyLoc");
            if (c && u) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            } else if (c) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            } else {
              if (!u) throw Error("try statement without catch or finally");
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(t, e) {
        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
          var o = this.tryEntries[r];
          if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
            var i = o;
            break;
          }
        }
        i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
        var a = i ? i.completion : {};
        return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
      },
      complete: function complete(t, e) {
        if ("throw" === t.type) throw t.arg;
        return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
      },
      finish: function finish(t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
        }
      },
      "catch": function _catch(t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.tryLoc === t) {
            var n = r.completion;
            if ("throw" === n.type) {
              var o = n.arg;
              resetTryEntry(r);
            }
            return o;
          }
        }
        throw Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(e, r, n) {
        return this.delegate = {
          iterator: values(e),
          resultName: r,
          nextLoc: n
        }, "next" === this.method && (this.arg = t), y;
      }
    }, e;
  }
  module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(regeneratorRuntime$1);
var regeneratorRuntimeExports = regeneratorRuntime$1.exports;

// TODO(Babel 8): Remove this file.

var runtime = regeneratorRuntimeExports();
var regenerator = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if ((typeof globalThis === "undefined" ? "undefined" : _typeof$2(globalThis)) === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
var _regeneratorRuntime = /*@__PURE__*/getDefaultExportFromCjs(regenerator);

/**
 * Types of block
 * @enum {string}
 */
var BlockType = {
  /**
   * Boolean reporter with hexagonal shape
   */
  BOOLEAN: 'Boolean',
  /**
   * A button (not an actual block) for some special action, like making a variable
   */
  BUTTON: 'button',
  /**
   * Command block
   */
  COMMAND: 'command',
  /**
   * Specialized command block which may or may not run a child branch
   * The thread continues with the next block whether or not a child branch ran.
   */
  CONDITIONAL: 'conditional',
  /**
   * Specialized hat block with no implementation function
   * This stack only runs if the corresponding event is emitted by other code.
   */
  EVENT: 'event',
  /**
   * Hat block which conditionally starts a block stack
   */
  HAT: 'hat',
  /**
   * Specialized command block which may or may not run a child branch
   * If a child branch runs, the thread evaluates the loop block again.
   */
  LOOP: 'loop',
  /**
   * General reporter with numeric or string value
   */
  REPORTER: 'reporter'
};
var blockType = BlockType;
var BlockType$1 = /*@__PURE__*/getDefaultExportFromCjs(blockType);

/**
 * Block argument types
 * @enum {string}
 */
var ArgumentType = {
  /**
   * Numeric value with angle picker
   */
  ANGLE: 'angle',
  /**
   * Boolean value with hexagonal placeholder
   */
  BOOLEAN: 'Boolean',
  /**
   * Numeric value with color picker
   */
  COLOR: 'color',
  /**
   * Numeric value with text field
   */
  NUMBER: 'number',
  /**
   * String value with text field
   */
  STRING: 'string',
  /**
   * String value with matrix field
   */
  MATRIX: 'matrix',
  /**
   * MIDI note number with note picker (piano) field
   */
  NOTE: 'note',
  /**
   * Inline image on block (as part of the label)
   */
  IMAGE: 'image'
};
var argumentType = ArgumentType;
var ArgumentType$1 = /*@__PURE__*/getDefaultExportFromCjs(argumentType);

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (String )(t);
}

function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

var Color$1 = /*#__PURE__*/function () {
  function Color() {
    _classCallCheck(this, Color);
  }
  return _createClass(Color, null, [{
    key: "RGB_BLACK",
    get:
    /**
     * @typedef {object} RGBObject - An object representing a color in RGB format.
     * @property {number} r - the red component, in the range [0, 255].
     * @property {number} g - the green component, in the range [0, 255].
     * @property {number} b - the blue component, in the range [0, 255].
     */

    /**
     * @typedef {object} HSVObject - An object representing a color in HSV format.
     * @property {number} h - hue, in the range [0-359).
     * @property {number} s - saturation, in the range [0,1].
     * @property {number} v - value, in the range [0,1].
     */

    /** @type {RGBObject} */
    function get() {
      return {
        r: 0,
        g: 0,
        b: 0
      };
    }

    /** @type {RGBObject} */
  }, {
    key: "RGB_WHITE",
    get: function get() {
      return {
        r: 255,
        g: 255,
        b: 255
      };
    }

    /**
     * Convert a Scratch decimal color to a hex string, #RRGGBB.
     * @param {number} decimal RGB color as a decimal.
     * @return {string} RGB color as #RRGGBB hex string.
     */
  }, {
    key: "decimalToHex",
    value: function decimalToHex(decimal) {
      if (decimal < 0) {
        decimal += 0xFFFFFF + 1;
      }
      var hex = Number(decimal).toString(16);
      hex = "#".concat('000000'.substr(0, 6 - hex.length)).concat(hex);
      return hex;
    }

    /**
     * Convert a Scratch decimal color to an RGB color object.
     * @param {number} decimal RGB color as decimal.
     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */
  }, {
    key: "decimalToRgb",
    value: function decimalToRgb(decimal) {
      var a = decimal >> 24 & 0xFF;
      var r = decimal >> 16 & 0xFF;
      var g = decimal >> 8 & 0xFF;
      var b = decimal & 0xFF;
      return {
        r: r,
        g: g,
        b: b,
        a: a > 0 ? a : 255
      };
    }

    /**
     * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.
     * CC-BY-SA Tim Down:
     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     * @param {!string} hex Hex representation of the color.
     * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */
  }, {
    key: "hexToRgb",
    value: function hexToRgb(hex) {
      var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
      });
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }

    /**
     * Convert an RGB color object to a hex color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {!string} Hex representation of the color.
     */
  }, {
    key: "rgbToHex",
    value: function rgbToHex(rgb) {
      return Color.decimalToHex(Color.rgbToDecimal(rgb));
    }

    /**
     * Convert an RGB color object to a Scratch decimal color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {!number} Number representing the color.
     */
  }, {
    key: "rgbToDecimal",
    value: function rgbToDecimal(rgb) {
      return (rgb.r << 16) + (rgb.g << 8) + rgb.b;
    }

    /**
    * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.
    * @param {!string} hex Hex representation of the color.
    * @return {!number} Number representing the color.
    */
  }, {
    key: "hexToDecimal",
    value: function hexToDecimal(hex) {
      return Color.rgbToDecimal(Color.hexToRgb(hex));
    }

    /**
     * Convert an HSV color to RGB format.
     * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */
  }, {
    key: "hsvToRgb",
    value: function hsvToRgb(hsv) {
      var h = hsv.h % 360;
      if (h < 0) h += 360;
      var s = Math.max(0, Math.min(hsv.s, 1));
      var v = Math.max(0, Math.min(hsv.v, 1));
      var i = Math.floor(h / 60);
      var f = h / 60 - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        case 5:
          r = v;
          g = p;
          b = q;
          break;
      }
      return {
        r: Math.floor(r * 255),
        g: Math.floor(g * 255),
        b: Math.floor(b * 255)
      };
    }

    /**
     * Convert an RGB color to HSV format.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     */
  }, {
    key: "rgbToHsv",
    value: function rgbToHsv(rgb) {
      var r = rgb.r / 255;
      var g = rgb.g / 255;
      var b = rgb.b / 255;
      var x = Math.min(Math.min(r, g), b);
      var v = Math.max(Math.max(r, g), b);

      // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate
      var h = 0;
      var s = 0;
      if (x !== v) {
        var f = r === x ? g - b : g === x ? b - r : r - g;
        var i = r === x ? 3 : g === x ? 5 : 1;
        h = (i - f / (v - x)) * 60 % 360;
        s = (v - x) / v;
      }
      return {
        h: h,
        s: s,
        v: v
      };
    }

    /**
     * Linear interpolation between rgb0 and rgb1.
     * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.
     * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.
     * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.
     * @return {RGBObject} the interpolated color.
     */
  }, {
    key: "mixRgb",
    value: function mixRgb(rgb0, rgb1, fraction1) {
      if (fraction1 <= 0) return rgb0;
      if (fraction1 >= 1) return rgb1;
      var fraction0 = 1 - fraction1;
      return {
        r: fraction0 * rgb0.r + fraction1 * rgb1.r,
        g: fraction0 * rgb0.g + fraction1 * rgb1.g,
        b: fraction0 * rgb0.b + fraction1 * rgb1.b
      };
    }
  }]);
}();
var color$3 = Color$1;

var Color = color$3;

/**
 * @fileoverview
 * Utilities for casting and comparing Scratch data-types.
 * Scratch behaves slightly differently from JavaScript in many respects,
 * and these differences should be encapsulated below.
 * For example, in Scratch, add(1, join("hello", world")) -> 1.
 * This is because "hello world" is cast to 0.
 * In JavaScript, 1 + Number("hello" + "world") would give you NaN.
 * Use when coercing a value before computation.
 */
var Cast = /*#__PURE__*/function () {
  function Cast() {
    _classCallCheck(this, Cast);
  }
  return _createClass(Cast, null, [{
    key: "toNumber",
    value:
    /**
     * Scratch cast to number.
     * Treats NaN as 0.
     * In Scratch 2.0, this is captured by `interp.numArg.`
     * @param {*} value Value to cast to number.
     * @return {number} The Scratch-casted number value.
     */
    function toNumber(value) {
      // If value is already a number we don't need to coerce it with
      // Number().
      if (typeof value === 'number') {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        if (Number.isNaN(value)) {
          return 0;
        }
        return value;
      }
      if (typeof value === 'string') {
        // Replace full-width numbers with half-width ones.
        value = value.replace(/[０-９＋．ｅ]/g, function (s) {
          return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
        });
        value = value.replace(/[-－﹣−‐⁃‑‒–—﹘―⎯⏤ーｰ─━]/g, '-');
      }
      var n = Number(value);
      if (Number.isNaN(n)) {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        return 0;
      }
      return n;
    }

    /**
     * Scratch cast to boolean.
     * In Scratch 2.0, this is captured by `interp.boolArg.`
     * Treats some string values differently from JavaScript.
     * @param {*} value Value to cast to boolean.
     * @return {boolean} The Scratch-casted boolean value.
     */
  }, {
    key: "toBoolean",
    value: function toBoolean(value) {
      // Already a boolean?
      if (typeof value === 'boolean') {
        return value;
      }
      if (typeof value === 'string') {
        // These specific strings are treated as false in Scratch.
        if (value === '' || value === '0' || value.toLowerCase() === 'false') {
          return false;
        }
        // All other strings treated as true.
        return true;
      }
      // Coerce other values and numbers.
      return Boolean(value);
    }

    /**
     * Scratch cast to string.
     * @param {*} value Value to cast to string.
     * @return {string} The Scratch-casted string value.
     */
  }, {
    key: "toString",
    value: function toString(value) {
      return String(value).replace(/\\n/g, '\n').replace(/\\t/g, '\t');
    }

    /**
     * Cast any Scratch argument to an RGB color array to be used for the renderer.
     * @param {*} value Value to convert to RGB color array.
     * @return {Array.<number>} [r,g,b], values between 0-255.
     */
  }, {
    key: "toRgbColorList",
    value: function toRgbColorList(value) {
      var color = Cast.toRgbColorObject(value);
      return [color.r, color.g, color.b];
    }

    /**
     * Cast any Scratch argument to an RGB color object to be used for the renderer.
     * @param {*} value Value to convert to RGB color object.
     * @return {RGBOject} [r,g,b], values between 0-255.
     */
  }, {
    key: "toRgbColorObject",
    value: function toRgbColorObject(value) {
      var color;
      if (typeof value === 'string' && value.substring(0, 1) === '#') {
        color = Color.hexToRgb(value);

        // If the color wasn't *actually* a hex color, cast to black
        if (!color) color = {
          r: 0,
          g: 0,
          b: 0,
          a: 255
        };
      } else {
        color = Color.decimalToRgb(Cast.toNumber(value));
      }
      return color;
    }

    /**
     * Determine if a Scratch argument is a white space string (or null / empty).
     * @param {*} val value to check.
     * @return {boolean} True if the argument is all white spaces or null / empty.
     */
  }, {
    key: "isWhiteSpace",
    value: function isWhiteSpace(val) {
      return val === null || typeof val === 'string' && val.trim().length === 0;
    }

    /**
     * Compare two values, using Scratch cast, case-insensitive string compare, etc.
     * In Scratch 2.0, this is captured by `interp.compare.`
     * @param {*} v1 First value to compare.
     * @param {*} v2 Second value to compare.
     * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.
     */
  }, {
    key: "compare",
    value: function compare(v1, v2) {
      var n1 = Number(v1);
      var n2 = Number(v2);
      if (n1 === 0 && Cast.isWhiteSpace(v1)) {
        n1 = NaN;
      } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {
        n2 = NaN;
      }
      if (isNaN(n1) || isNaN(n2)) {
        // At least one argument can't be converted to a number.
        // Scratch compares strings as case insensitive.
        var s1 = Cast.toString(v1).toLowerCase();
        var s2 = Cast.toString(v2).toLowerCase();
        if (s1 < s2) {
          return -1;
        } else if (s1 > s2) {
          return 1;
        }
        return 0;
      }
      // Handle the special case of Infinity
      if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {
        return 0;
      }
      // Compare as numbers.
      return n1 - n2;
    }

    /**
     * Determine if a Scratch argument number represents a round integer.
     * @param {*} val Value to check.
     * @return {boolean} True if number looks like an integer.
     */
  }, {
    key: "isInt",
    value: function isInt(val) {
      // Values that are already numbers.
      if (typeof val === 'number') {
        if (isNaN(val)) {
          // NaN is considered an integer.
          return true;
        }
        // True if it's "round" (e.g., 2.0 and 2).
        return val === parseInt(val, 10);
      } else if (typeof val === 'boolean') {
        // `True` and `false` always represent integer after Scratch cast.
        return true;
      } else if (typeof val === 'string') {
        // If it contains a decimal point, don't consider it an int.
        return val.indexOf('.') < 0;
      }
      return false;
    }
  }, {
    key: "LIST_INVALID",
    get: function get() {
      return 'INVALID';
    }
  }, {
    key: "LIST_ALL",
    get: function get() {
      return 'ALL';
    }

    /**
     * Compute a 1-based index into a list, based on a Scratch argument.
     * Two special cases may be returned:
     * LIST_ALL: if the block is referring to all of the items in the list.
     * LIST_INVALID: if the index was invalid in any way.
     * @param {*} index Scratch arg, including 1-based numbers or special cases.
     * @param {number} length Length of the list.
     * @param {boolean} acceptAll Whether it should accept "all" or not.
     * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.
     */
  }, {
    key: "toListIndex",
    value: function toListIndex(index, length, acceptAll) {
      if (typeof index !== 'number') {
        if (index === 'all') {
          return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;
        }
        if (index === 'last') {
          if (length > 0) {
            return length;
          }
          return Cast.LIST_INVALID;
        } else if (index === 'random' || index === 'any') {
          if (length > 0) {
            return 1 + Math.floor(Math.random() * length);
          }
          return Cast.LIST_INVALID;
        }
      }
      index = Math.floor(Cast.toNumber(index));
      if (index < 1 || index > length) {
        return Cast.LIST_INVALID;
      }
      return index;
    }
  }]);
}();
var cast = Cast;
var Cast$1 = /*@__PURE__*/getDefaultExportFromCjs(cast);

var web = {exports: {}};

var minilog$2 = {exports: {}};

function M() {
  this._events = {};
}
M.prototype = {
  on: function on(ev, cb) {
    this._events || (this._events = {});
    var e = this._events;
    (e[ev] || (e[ev] = [])).push(cb);
    return this;
  },
  removeListener: function removeListener(ev, cb) {
    var e = this._events[ev] || [],
      i;
    for (i = e.length - 1; i >= 0 && e[i]; i--) {
      if (e[i] === cb || e[i].cb === cb) {
        e.splice(i, 1);
      }
    }
  },
  removeAllListeners: function removeAllListeners(ev) {
    if (!ev) {
      this._events = {};
    } else {
      this._events[ev] && (this._events[ev] = []);
    }
  },
  listeners: function listeners(ev) {
    return this._events ? this._events[ev] || [] : [];
  },
  emit: function emit(ev) {
    this._events || (this._events = {});
    var args = Array.prototype.slice.call(arguments, 1),
      i,
      e = this._events[ev] || [];
    for (i = e.length - 1; i >= 0 && e[i]; i--) {
      e[i].apply(this, args);
    }
    return this;
  },
  when: function when(ev, cb) {
    return this.once(ev, cb, true);
  },
  once: function once(ev, cb, when) {
    if (!cb) return this;
    function c() {
      if (!when) this.removeListener(ev, c);
      if (cb.apply(this, arguments) && when) this.removeListener(ev, c);
    }
    c.cb = cb;
    this.on(ev, c);
    return this;
  }
};
M.mixin = function (dest) {
  var o = M.prototype,
    k;
  for (k in o) {
    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);
  }
};
var microee$1 = M;

var microee = microee$1;

// Implements a subset of Node's stream.Transform - in a cross-platform manner.
function Transform$4() {}
microee.mixin(Transform$4);

// The write() signature is different from Node's
// --> makes it much easier to work with objects in logs.
// One of the lessons from v1 was that it's better to target
// a good browser rather than the lowest common denominator
// internally.
// If you want to use external streams, pipe() to ./stringify.js first.
Transform$4.prototype.write = function (name, level, args) {
  this.emit('item', name, level, args);
};
Transform$4.prototype.end = function () {
  this.emit('end');
  this.removeAllListeners();
};
Transform$4.prototype.pipe = function (dest) {
  var s = this;
  // prevent double piping
  s.emit('unpipe', dest);
  // tell the dest that it's being piped to
  dest.emit('pipe', s);
  function onItem() {
    dest.write.apply(dest, Array.prototype.slice.call(arguments));
  }
  function onEnd() {
    !dest._isStdio && dest.end();
  }
  s.on('item', onItem);
  s.on('end', onEnd);
  s.when('unpipe', function (from) {
    var match = from === dest || typeof from == 'undefined';
    if (match) {
      s.removeListener('item', onItem);
      s.removeListener('end', onEnd);
      dest.emit('unpipe');
    }
    return match;
  });
  return dest;
};
Transform$4.prototype.unpipe = function (from) {
  this.emit('unpipe', from);
  return this;
};
Transform$4.prototype.format = function (dest) {
  throw new Error(['Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:', 'var Minilog = require(\'minilog\');', 'Minilog', '  .pipe(Minilog.backends.console.formatClean)', '  .pipe(Minilog.backends.console);'].join('\n'));
};
Transform$4.mixin = function (dest) {
  var o = Transform$4.prototype,
    k;
  for (k in o) {
    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);
  }
};
var transform = Transform$4;

// default filter
var Transform$3 = transform;
var levelMap = {
  debug: 1,
  info: 2,
  warn: 3,
  error: 4
};
function Filter() {
  this.enabled = true;
  this.defaultResult = true;
  this.clear();
}
Transform$3.mixin(Filter);

// allow all matching, with level >= given level
Filter.prototype.allow = function (name, level) {
  this._white.push({
    n: name,
    l: levelMap[level]
  });
  return this;
};

// deny all matching, with level <= given level
Filter.prototype.deny = function (name, level) {
  this._black.push({
    n: name,
    l: levelMap[level]
  });
  return this;
};
Filter.prototype.clear = function () {
  this._white = [];
  this._black = [];
  return this;
};
function test(rule, name) {
  // use .test for RegExps
  return rule.n.test ? rule.n.test(name) : rule.n == name;
}
Filter.prototype.test = function (name, level) {
  var i,
    len = Math.max(this._white.length, this._black.length);
  for (i = 0; i < len; i++) {
    if (this._white[i] && test(this._white[i], name) && levelMap[level] >= this._white[i].l) {
      return true;
    }
    if (this._black[i] && test(this._black[i], name) && levelMap[level] <= this._black[i].l) {
      return false;
    }
  }
  return this.defaultResult;
};
Filter.prototype.write = function (name, level, args) {
  if (!this.enabled || this.test(name, level)) {
    return this.emit('item', name, level, args);
  }
};
var filter = Filter;

(function (module, exports) {
  var Transform = transform,
    Filter = filter;
  var log = new Transform(),
    slice = Array.prototype.slice;
  exports = module.exports = function create(name) {
    var _o = function o() {
      log.write(name, undefined, slice.call(arguments));
      return _o;
    };
    _o.debug = function () {
      log.write(name, 'debug', slice.call(arguments));
      return _o;
    };
    _o.info = function () {
      log.write(name, 'info', slice.call(arguments));
      return _o;
    };
    _o.warn = function () {
      log.write(name, 'warn', slice.call(arguments));
      return _o;
    };
    _o.error = function () {
      log.write(name, 'error', slice.call(arguments));
      return _o;
    };
    _o.log = _o.debug; // for interface compliance with Node and browser consoles
    _o.suggest = exports.suggest;
    _o.format = log.format;
    return _o;
  };

  // filled in separately
  exports.defaultBackend = exports.defaultFormatter = null;
  exports.pipe = function (dest) {
    return log.pipe(dest);
  };
  exports.end = exports.unpipe = exports.disable = function (from) {
    return log.unpipe(from);
  };
  exports.Transform = Transform;
  exports.Filter = Filter;
  // this is the default filter that's applied when .enable() is called normally
  // you can bypass it completely and set up your own pipes
  exports.suggest = new Filter();
  exports.enable = function () {
    if (exports.defaultFormatter) {
      return log.pipe(exports.suggest) // filter
      .pipe(exports.defaultFormatter) // formatter
      .pipe(exports.defaultBackend); // backend
    }
    return log.pipe(exports.suggest) // filter
    .pipe(exports.defaultBackend); // formatter
  };
})(minilog$2, minilog$2.exports);
var minilogExports = minilog$2.exports;

var hex = {
  black: '#000',
  red: '#c23621',
  green: '#25bc26',
  yellow: '#bbbb00',
  blue: '#492ee1',
  magenta: '#d338d3',
  cyan: '#33bbc8',
  gray: '#808080',
  purple: '#708'
};
function color$2(fg, isInverse) {
  if (isInverse) {
    return 'color: #fff; background: ' + hex[fg] + ';';
  } else {
    return 'color: ' + hex[fg] + ';';
  }
}
var util = color$2;

var Transform$2 = transform,
  color$1 = util;
var colors$1 = {
    debug: ['cyan'],
    info: ['purple'],
    warn: ['yellow', true],
    error: ['red', true]
  },
  logger$2 = new Transform$2();
logger$2.write = function (name, level, args) {
  var fn = console.log;
  if (console[level] && console[level].apply) {
    fn = console[level];
    fn.apply(console, ['%c' + name + ' %c' + level, color$1('gray'), color$1.apply(color$1, colors$1[level])].concat(args));
  }
};

// NOP, because piping the formatted logs can only cause trouble.
logger$2.pipe = function () {};
var color_1 = logger$2;

var Transform$1 = transform,
  color = util,
  colors = {
    debug: ['gray'],
    info: ['purple'],
    warn: ['yellow', true],
    error: ['red', true]
  },
  logger$1 = new Transform$1();
logger$1.write = function (name, level, args) {
  var fn = console.log;
  if (level != 'debug' && console[level]) {
    fn = console[level];
  }
  var i = 0;
  if (level != 'info') {
    for (; i < args.length; i++) {
      if (typeof args[i] != 'string') break;
    }
    fn.apply(console, ['%c' + name + ' ' + args.slice(0, i).join(' '), color.apply(color, colors[level])].concat(args.slice(i)));
  } else {
    fn.apply(console, ['%c' + name, color.apply(color, colors[level])].concat(args));
  }
};

// NOP, because piping the formatted logs can only cause trouble.
logger$1.pipe = function () {};
var minilog$1 = logger$1;

var Transform = transform;
var newlines = /\n+$/,
  logger = new Transform();
logger.write = function (name, level, args) {
  var i = args.length - 1;
  if (typeof console === 'undefined' || !console.log) {
    return;
  }
  if (console.log.apply) {
    return console.log.apply(console, [name, level].concat(args));
  } else if (JSON && JSON.stringify) {
    // console.log.apply is undefined in IE8 and IE9
    // for IE8/9: make console.log at least a bit less awful
    if (args[i] && typeof args[i] == 'string') {
      args[i] = args[i].replace(newlines, '');
    }
    try {
      for (i = 0; i < args.length; i++) {
        args[i] = JSON.stringify(args[i]);
      }
    } catch (e) {}
    console.log(args.join(' '));
  }
};
logger.formatters = ['color', 'minilog'];
logger.color = color_1;
logger.minilog = minilog$1;
var console_1 = logger;

var array;
var hasRequiredArray;
function requireArray() {
  if (hasRequiredArray) return array;
  hasRequiredArray = 1;
  var Transform = transform,
    cache = [];
  var logger = new Transform();
  logger.write = function (name, level, args) {
    cache.push([name, level, args]);
  };

  // utility functions
  logger.get = function () {
    return cache;
  };
  logger.empty = function () {
    cache = [];
  };
  array = logger;
  return array;
}

var localstorage;
var hasRequiredLocalstorage;
function requireLocalstorage() {
  if (hasRequiredLocalstorage) return localstorage;
  hasRequiredLocalstorage = 1;
  var Transform = transform,
    cache = false;
  var logger = new Transform();
  logger.write = function (name, level, args) {
    if (typeof window == 'undefined' || typeof JSON == 'undefined' || !JSON.stringify || !JSON.parse) return;
    try {
      if (!cache) {
        cache = window.localStorage.minilog ? JSON.parse(window.localStorage.minilog) : [];
      }
      cache.push([new Date().toString(), name, level, args]);
      window.localStorage.minilog = JSON.stringify(cache);
    } catch (e) {}
  };
  localstorage = logger;
  return localstorage;
}

var jquery_simple;
var hasRequiredJquery_simple;
function requireJquery_simple() {
  if (hasRequiredJquery_simple) return jquery_simple;
  hasRequiredJquery_simple = 1;
  var Transform = transform;
  var cid = new Date().valueOf().toString(36);
  function AjaxLogger(options) {
    this.url = options.url || '';
    this.cache = [];
    this.timer = null;
    this.interval = options.interval || 30 * 1000;
    this.enabled = true;
    this.jQuery = window.jQuery;
    this.extras = {};
  }
  Transform.mixin(AjaxLogger);
  AjaxLogger.prototype.write = function (name, level, args) {
    if (!this.timer) {
      this.init();
    }
    this.cache.push([name, level].concat(args));
  };
  AjaxLogger.prototype.init = function () {
    if (!this.enabled || !this.jQuery) return;
    var self = this;
    this.timer = setTimeout(function () {
      var i,
        logs = [],
        ajaxData,
        url = self.url;
      if (self.cache.length == 0) return self.init();
      // Test each log line and only log the ones that are valid (e.g. don't have circular references).
      // Slight performance hit but benefit is we log all valid lines.
      for (i = 0; i < self.cache.length; i++) {
        try {
          JSON.stringify(self.cache[i]);
          logs.push(self.cache[i]);
        } catch (e) {}
      }
      if (self.jQuery.isEmptyObject(self.extras)) {
        ajaxData = JSON.stringify({
          logs: logs
        });
        url = self.url + '?client_id=' + cid;
      } else {
        ajaxData = JSON.stringify(self.jQuery.extend({
          logs: logs
        }, self.extras));
      }
      self.jQuery.ajax(url, {
        type: 'POST',
        cache: false,
        processData: false,
        data: ajaxData,
        contentType: 'application/json',
        timeout: 10000
      }).success(function (data, status, jqxhr) {
        if (data.interval) {
          self.interval = Math.max(1000, data.interval);
        }
      }).error(function () {
        self.interval = 30000;
      }).always(function () {
        self.init();
      });
      self.cache = [];
    }, this.interval);
  };
  AjaxLogger.prototype.end = function () {};

  // wait until jQuery is defined. Useful if you don't control the load order.
  AjaxLogger.jQueryWait = function (onDone) {
    if (typeof window !== 'undefined' && (window.jQuery || window.$)) {
      return onDone(window.jQuery || window.$);
    } else if (typeof window !== 'undefined') {
      setTimeout(function () {
        AjaxLogger.jQueryWait(onDone);
      }, 200);
    }
  };
  jquery_simple = AjaxLogger;
  return jquery_simple;
}

(function (module, exports) {
  var Minilog = minilogExports;
  var oldEnable = Minilog.enable,
    oldDisable = Minilog.disable,
    isChrome = typeof navigator != 'undefined' && /chrome/i.test(navigator.userAgent),
    console = console_1;

  // Use a more capable logging backend if on Chrome
  Minilog.defaultBackend = isChrome ? console.minilog : console;

  // apply enable inputs from localStorage and from the URL
  if (typeof window != 'undefined') {
    try {
      Minilog.enable(JSON.parse(window.localStorage['minilogSettings']));
    } catch (e) {}
    if (window.location && window.location.search) {
      var match = RegExp('[?&]minilog=([^&]*)').exec(window.location.search);
      match && Minilog.enable(decodeURIComponent(match[1]));
    }
  }

  // Make enable also add to localStorage
  Minilog.enable = function () {
    oldEnable.call(Minilog, true);
    try {
      window.localStorage['minilogSettings'] = JSON.stringify(true);
    } catch (e) {}
    return this;
  };
  Minilog.disable = function () {
    oldDisable.call(Minilog);
    try {
      delete window.localStorage.minilogSettings;
    } catch (e) {}
    return this;
  };
  exports = module.exports = Minilog;
  exports.backends = {
    array: requireArray(),
    browser: Minilog.defaultBackend,
    localStorage: requireLocalstorage(),
    jQuery: requireJquery_simple()
  };
})(web, web.exports);
var webExports = web.exports;

var minilog = webExports;
minilog.enable();
var log = minilog('vm');
var log$1 = /*@__PURE__*/getDefaultExportFromCjs(log);

var en = {
	"xcxAudioAnalyser.name": "Audio Analyser",
	"xcxAudioAnalyser.sampleSoundData": "sample sound [DOMAIN] by [FFT_WINDOW] windows",
	"xcxAudioAnalyser.frequencyLevel": "level of frequency [FREQUENCY] Hz",
	"xcxAudioAnalyser.frequencyDomainMin": "min decibel of frequency analyser",
	"xcxAudioAnalyser.frequencyDomainMax": "max decibel of frequency analyser",
	"xcxAudioAnalyser.waveformLevel": "level of waveform at [INDEX]",
	"xcxAudioAnalyser.waveformDataLength": "data length of waveform",
	"xcxAudioAnalyser.timeDomain": "time domain",
	"xcxAudioAnalyser.frequencyDomain": "frequency domain"
};
var ja = {
	"xcxAudioAnalyser.name": "Audio Analyser",
	"xcxAudioAnalyser.sampleSoundData": "音の [DOMAIN] データを窓 [FFT_WINDOW] でとる",
	"xcxAudioAnalyser.frequencyLevel": "周波数 [FREQUENCY] Hz のレベル",
	"xcxAudioAnalyser.frequencyDomainMin": "周波数アナライザーの最小デシベル",
	"xcxAudioAnalyser.frequencyDomainMax": "周波数アナライザーの最大デシベル",
	"xcxAudioAnalyser.waveformLevel": "[INDEX] 番目の波形のレベル",
	"xcxAudioAnalyser.waveformDataLength": "波形データの長さ",
	"xcxAudioAnalyser.timeDomain": "時間領域",
	"xcxAudioAnalyser.frequencyDomain": "周波数領域"
};
var translations = {
	en: en,
	ja: ja,
	"ja-Hira": {
	"xcxAudioAnalyser.name": "オーディオ アナライザー",
	"xcxAudioAnalyser.doIt": "[SCRIPT] を じっこう する",
	"xcxAudioAnalyser.sampleSoundData": "おと の [DOMAIN] データ を まど [FFT_WINDOW] で とる",
	"xcxAudioAnalyser.frequencyLevel": "しゅうはすう [FREQUENCY] Hz の レベル",
	"xcxAudioAnalyser.frequencyDomainMin": "しゅうはすう アナライザー の さいしょう デシベル",
	"xcxAudioAnalyser.frequencyDomainMax": "しゅうはすう アナライザー の さいだい デシベル",
	"xcxAudioAnalyser.waveformLevel": "[INDEX] ばんめ の はけい の レベル",
	"xcxAudioAnalyser.waveformDataLength": "はけい データ の ながさ",
	"xcxAudioAnalyser.timeDomain": "じかんりょういき",
	"xcxAudioAnalyser.frequencyDomain": "しゅうはすうりょういき"
}
};

var img = "data:image/png;base64,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";

/**
 * List of FFT window sizes.
 * @type {number[]}
 */
var FFT_WINDOW_LIST = [32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768];

/**
 * Formatter which is used for translation.
 * This will be replaced which is used in the runtime.
 * @param {object} messageData - format-message object
 * @returns {string} - message for the locale
 */
var formatMessage = function formatMessage(messageData) {
  return messageData.default;
};

/**
 * Setup format-message for this extension.
 */
var setupTranslations = function setupTranslations() {
  var localeSetup = formatMessage.setup();
  if (localeSetup && localeSetup.translations[localeSetup.locale]) {
    Object.assign(localeSetup.translations[localeSetup.locale], translations[localeSetup.locale]);
  }
};
var EXTENSION_ID = 'xcxAudioAnalyser';

/**
 * URL to get this extension as a module.
 * When it was loaded as a module, 'extensionURL' will be replaced a URL which is retrieved from.
 * @type {string}
 */
var extensionURL = 'https://yokobond.github.io/xcx-audio-analyser/dist/xcxAudioAnalyser.mjs';

/**
 * Scratch 3.0 blocks for example of Xcratch.
 */
var ExtensionBlocks = /*#__PURE__*/function () {
  /**
   * Construct a set of blocks for Audio Analyser.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */
  function ExtensionBlocks(runtime) {
    _classCallCheck$1(this, ExtensionBlocks);
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime;
    if (runtime.formatMessage) {
      // Replace 'formatMessage' to a formatter which is used in the runtime.
      formatMessage = runtime.formatMessage;
    }

    /**
     * Audio context.
     * @type {AudioContext}
     */
    this.audioContext = null;

    /**
     * Analyser node.
     * @type {AnalyserNode}
     */
    this.analyser = null;

    /**
     * Frequency data.
     * @type {Uint8Array}
     */
    this.frequencyData = null;

    /**
     * Time data.
     * @type {Uint8Array}
     */
    this.timeData = null;
  }

  /**
   * @returns {object} metadata for this extension and its blocks.
   */
  return _createClass$1(ExtensionBlocks, [{
    key: "getInfo",
    value: function getInfo() {
      setupTranslations();
      return {
        id: ExtensionBlocks.EXTENSION_ID,
        name: ExtensionBlocks.EXTENSION_NAME,
        extensionURL: ExtensionBlocks.extensionURL,
        blockIconURI: img,
        showStatusButton: false,
        blocks: [{
          opcode: 'sampleSoundData',
          blockType: BlockType$1.COMMAND,
          blockAllThreads: false,
          text: formatMessage({
            id: 'xcxAudioAnalyser.sampleSoundData',
            default: 'sample sound [DOMAIN] by [FFT_WINDOW] windows',
            description: 'get sound data for FFT'
          }),
          func: 'sampleSoundData',
          arguments: {
            DOMAIN: {
              type: ArgumentType$1.STRING,
              menu: 'domainMenu',
              defaultValue: 'time'
            },
            FFT_WINDOW: {
              type: ArgumentType$1.STRING,
              menu: 'fftWindowMenu',
              defaultValue: '2048'
            }
          }
        }, {
          opcode: 'frequencyLevel',
          blockType: BlockType$1.REPORTER,
          blockAllThreads: false,
          text: formatMessage({
            id: 'xcxAudioAnalyser.frequencyLevel',
            default: 'level of frequency [FREQUENCY] Hz',
            description: 'get level of frequency'
          }),
          func: 'frequencyLevel',
          arguments: {
            FREQUENCY: {
              type: ArgumentType$1.NUMBER,
              defaultValue: 440
            }
          }
        }, {
          opcode: 'frequencyDomainMin',
          blockType: BlockType$1.REPORTER,
          disableMonitor: true,
          blockAllThreads: false,
          text: formatMessage({
            id: 'xcxAudioAnalyser.frequencyDomainMin',
            default: 'min decibel of frequency analyser',
            description: 'get min decibel of frequency analyser'
          }),
          func: 'frequencyDomainMin',
          arguments: {}
        }, {
          opcode: 'frequencyDomainMax',
          blockType: BlockType$1.REPORTER,
          disableMonitor: true,
          blockAllThreads: false,
          text: formatMessage({
            id: 'xcxAudioAnalyser.frequencyDomainMax',
            default: 'max decibel of frequency analyser',
            description: 'get max decibel of frequency analyser'
          }),
          func: 'frequencyDomainMax',
          arguments: {}
        }, {
          opcode: 'waveformLevel',
          blockType: BlockType$1.REPORTER,
          disableMonitor: true,
          blockAllThreads: false,
          text: formatMessage({
            id: 'xcxAudioAnalyser.waveformLevel',
            default: 'level of waveform at [INDEX]',
            description: 'get level of waveform'
          }),
          func: 'waveformLevel',
          arguments: {
            INDEX: {
              type: ArgumentType$1.NUMBER,
              defaultValue: 1
            }
          }
        }, {
          opcode: 'waveformDataLength',
          blockType: BlockType$1.REPORTER,
          disableMonitor: true,
          blockAllThreads: false,
          text: formatMessage({
            id: 'xcxAudioAnalyser.waveformDataLength',
            default: 'data length of waveform',
            description: 'get length of waveform data'
          }),
          func: 'waveformDataLength',
          arguments: {}
        }],
        menus: {
          domainMenu: {
            acceptReporters: false,
            items: 'getDomainMenu'
          },
          fftWindowMenu: {
            acceptReporters: true,
            items: 'getFFTWindowMenu'
          }
        }
      };
    }
  }, {
    key: "getDomainMenu",
    value: function getDomainMenu() {
      var menu = [{
        text: formatMessage({
          id: 'xcxAudioAnalyser.timeDomain',
          default: 'time domain',
          description: 'time domain'
        }),
        value: 'time'
      }, {
        text: formatMessage({
          id: 'xcxAudioAnalyser.frequencyDomain',
          default: 'frequency domain',
          description: 'frequency domain'
        }),
        value: 'frequency'
      }];
      return menu;
    }

    /**
     * Get FFT window menu.
     * @return {array} FFT window menu
     */
  }, {
    key: "getFFTWindowMenu",
    value: function getFFTWindowMenu() {
      var menu = [];
      for (var _i = 0, _FFT_WINDOW_LIST = FFT_WINDOW_LIST; _i < _FFT_WINDOW_LIST.length; _i++) {
        var fftWindow = _FFT_WINDOW_LIST[_i];
        menu.push({
          text: String(fftWindow),
          value: String(fftWindow)
        });
      }
      return menu;
    }

    /**
     * Get audio context.
     * If audio context is not created, create it.
     * @param {object} options - options for constructor of AudioContext
     * @return {AudioContext} audio context
     */
  }, {
    key: "getAudioContext",
    value: function getAudioContext(options) {
      if (!this.audioContext) {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)(options);
      }
      return this.audioContext;
    }

    /**
     * Get sound source.
     * If sound source is not created, create it.
     * @return {Promise<MediaStreamAudioSourceNode>} sound source
     */
  }, {
    key: "getSoundSource",
    value: (function () {
      var _getSoundSource = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var stream;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this.soundSource) {
                _context.next = 5;
                break;
              }
              _context.next = 3;
              return navigator.mediaDevices.getUserMedia({
                audio: true
              });
            case 3:
              stream = _context.sent;
              this.soundSource = this.getAudioContext().createMediaStreamSource(stream);
            case 5:
              return _context.abrupt("return", this.soundSource);
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getSoundSource() {
        return _getSoundSource.apply(this, arguments);
      }
      return getSoundSource;
    }()
    /**
     * Get analyser node.
     * If analyser node is not created, create it.
     * @return {Promise<AnalyserNode>} analyser
     */
    )
  }, {
    key: "getAnalyser",
    value: (function () {
      var _getAnalyser = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var source;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (this.analyser) {
                _context2.next = 7;
                break;
              }
              if (this.analyser) {
                this.analyser.disconnect();
                this.analyser = null;
              }
              _context2.next = 4;
              return this.getSoundSource();
            case 4:
              source = _context2.sent;
              this.analyser = this.getAudioContext().createAnalyser();
              source.connect(this.analyser);
            case 7:
              return _context2.abrupt("return", this.analyser);
            case 8:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getAnalyser() {
        return _getAnalyser.apply(this, arguments);
      }
      return getAnalyser;
    }()
    /**
     * Get sound data for FFT.
     * @param {object} args - arguments for the block
     * @param {string} args.FFT_WINDOW - FFT window size.
     * @returns {Promise<string>} - a promise which resolves when sound data is sampled.
     */
    )
  }, {
    key: "sampleSoundData",
    value: (function () {
      var _sampleSoundData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(args) {
        var domain, windowSize, fftSize, index, analyser, bufferLength;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              domain = Cast$1.toString(args.DOMAIN);
              windowSize = Cast$1.toNumber(args.FFT_WINDOW);
              fftSize = FFT_WINDOW_LIST[0];
              index = 1;
            case 4:
              if (!(index < FFT_WINDOW_LIST.length)) {
                _context3.next = 11;
                break;
              }
              fftSize = FFT_WINDOW_LIST[index];
              if (!(fftSize >= windowSize)) {
                _context3.next = 8;
                break;
              }
              return _context3.abrupt("break", 11);
            case 8:
              index++;
              _context3.next = 4;
              break;
            case 11:
              _context3.prev = 11;
              _context3.next = 14;
              return this.getAnalyser();
            case 14:
              analyser = _context3.sent;
              if (analyser.fftSize !== fftSize) {
                analyser.fftSize = fftSize;
              }
              if (!(domain === 'frequency')) {
                _context3.next = 23;
                break;
              }
              bufferLength = analyser.frequencyBinCount;
              this.frequencyData = new Uint8Array(bufferLength);
              this.analyser.getByteFrequencyData(this.frequencyData);
              return _context3.abrupt("return", "frequency domain with FFT Window: ".concat(fftSize, " on sample rate: ").concat(this.audioContext.sampleRate));
            case 23:
              if (!(domain === 'time')) {
                _context3.next = 27;
                break;
              }
              this.timeData = new Uint8Array(fftSize);
              this.analyser.getByteTimeDomainData(this.timeData);
              return _context3.abrupt("return", "time domain with FFT Window: ".concat(fftSize, " on sample rate: ").concat(this.audioContext.sampleRate));
            case 27:
              _context3.next = 33;
              break;
            case 29:
              _context3.prev = 29;
              _context3.t0 = _context3["catch"](11);
              log$1.error(_context3.t0);
              return _context3.abrupt("return", _context3.t0.message);
            case 33:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[11, 29]]);
      }));
      function sampleSoundData(_x) {
        return _sampleSoundData.apply(this, arguments);
      }
      return sampleSoundData;
    }()
    /**
     * Get frequency level.
     * @param {object} args - arguments for the block
     * @param {number} args.FREQUENCY - frequency
     * @returns {number} frequency level
     */
    )
  }, {
    key: "frequencyLevel",
    value: function frequencyLevel(args) {
      if (!this.frequencyData) {
        return 0;
      }
      var frequency = Cast$1.toNumber(args.FREQUENCY);
      var sampleRate = this.audioContext.sampleRate;
      var resolution = sampleRate / 2 / this.frequencyData.length;
      var index = Math.trunc(frequency / resolution);
      if (index < 0) {
        return 0;
      }
      if (index >= this.frequencyData.length) {
        return 0;
      }
      var level = 100 * this.frequencyData[index] / 255;
      return level;
    }

    /**
     * Get minimum decibel for frequency domain.
     * @returns {number} minimum decibel
     */
  }, {
    key: "frequencyDomainMin",
    value: function frequencyDomainMin() {
      if (!this.analyser) {
        return 0;
      }
      return this.analyser.minDecibels;
    }

    /**
     * Get maximum decibel for frequency domain.
     * @returns {number} maximum decibel
     */
  }, {
    key: "frequencyDomainMax",
    value: function frequencyDomainMax() {
      if (!this.analyser) {
        return 0;
      }
      return this.analyser.maxDecibels;
    }

    /**
     * Get waveform level at the window index.
     * @param {object} args - arguments for the block
     * @param {number} args.INDEX - 1-based index of the window
     * @returns {number} waveform level
     */
  }, {
    key: "waveformLevel",
    value: function waveformLevel(args) {
      if (!this.timeData) {
        return 0;
      }
      var index = Math.trunc(Cast$1.toNumber(args.INDEX)) - 1;
      if (index < 0) {
        return 0;
      }
      if (index >= this.timeData.length) {
        return 0;
      }
      var level = 100 * this.timeData[index] / 255 - 50;
      return level;
    }

    /**
     * Get length of waveform data.
     * @returns {number} length of waveform data
     */
  }, {
    key: "waveformDataLength",
    value: function waveformDataLength() {
      if (!this.timeData) {
        return 0;
      }
      return this.timeData.length;
    }
  }], [{
    key: "formatMessage",
    set:
    /**
     * A translation object which is used in this class.
     * @param {FormatObject} formatter - translation object
     */
    function set(formatter) {
      formatMessage = formatter;
      if (formatMessage) setupTranslations();
    }

    /**
     * @return {string} - the name of this extension.
     */
  }, {
    key: "EXTENSION_NAME",
    get: function get() {
      return formatMessage({
        id: 'xcxAudioAnalyser.name',
        default: 'Audio Analyser',
        description: 'name of the extension'
      });
    }

    /**
     * @return {string} - the ID of this extension.
     */
  }, {
    key: "EXTENSION_ID",
    get: function get() {
      return EXTENSION_ID;
    }

    /**
     * URL to get this extension.
     * @type {string}
     */
  }, {
    key: "extensionURL",
    get: function get() {
      return extensionURL;
    }

    /**
     * Set URL to get this extension.
     * The extensionURL will be changed to the URL of the loading server.
     * @param {string} url - URL
     */,
    set: function set(url) {
      extensionURL = url;
    }
  }]);
}();

export { ExtensionBlocks as blockClass, entry };
//# sourceMappingURL=xcxAudioAnalyser.mjs.map
